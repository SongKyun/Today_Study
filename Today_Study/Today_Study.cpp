/*### 1️⃣ **[언리얼]**

**Q. 언리얼 엔진에서 Garbage Collection(GC) 시스템의 작동 방식과, GC 대상이 되기 위한 조건은 무엇인가요?**

> 🔍 의도: UPROPERTY 시스템과 UObject 메모리 관리 이해도 평가
> 

<aside>
💡

언리얼의 GC 시스템은 UObject 기반 객체를 자동으로 해제하며, UPROPERTY()로 마킹된 포인터만 참조 추적으로 인식되어, 누수를 방지할 수 있다.

</aside>

- **개념**
    
    ## 🔷 1. 마크 & 스윕(Mark and Sweep) 방식이란?
    
    > GC의 대표적인 메모리 수거 알고리즘 중 하나로,
    > 
    > 
    > 객체 참조 그래프를 따라가며 **살아있는 객체(marked)** 와 **죽은 객체(unreachable)** 를 구분하여 제거합니다.
    > 
    
    ---
    
    ### ✅ 작동 원리
    
    1. **Mark 단계 (표시 단계)**
        - 루트 객체(예: Level, World, PlayerController 등)부터 시작해서
        - `UPROPERTY()`로 연결된 포인터를 따라가며
        - **도달 가능한 객체에 마크(표시)** 를 함
    2. **Sweep 단계 (정리 단계)**
        - 전체 `UObject` 풀을 훑으며
        - **마크되지 않은 객체를 "더 이상 사용하지 않음"으로 판단 → 메모리 해제**
    
    ---
    
    ### 💡 특징
    
    - 살아있는 객체만 추적하므로 **메모리 누수 방지**
    - 마크 기준은 오직 `UPROPERTY()`를 통해 연결된 포인터
    - 퍼포먼스에 영향 줄 수 있어 **GC 호출은 프레임에 따라 제한적** (최대 허용 시간 설정 가능)
    
    ## 🔷 2. UObject란?
    
    > 언리얼 엔진에서 모든 엔진 기능과 메모리 관리, 직렬화, 리플리케이션, 에디터 통합 등을 위한 핵심 기반 클래스입니다.
    > 
    
    ---
    
    ### ✅ UObject의 주요 특징
    
    | 항목 | 설명 |
    | --- | --- |
    | 기본 클래스 | 모든 언리얼 클래스는 `UObject` 혹은 그 하위 클래스에서 파생됨 (`AActor`, `UActorComponent`, `UBlueprintFunctionLibrary` 등) |
    | GC 대상 | `NewObject<T>()`, `DuplicateObject()` 등으로 생성 시 GC 대상 |
    | 메타 시스템 지원 | 리플렉션, 직렬화, 네트워크 전송, 에디터 노출 가능 |
    | 메모리 자동 관리 | UPROPERTY와 함께 GC에 의해 관리됨 |
    
    ---
    
    ### 📌 UObject와 new/delete의 차이
    
    | 방식 | 설명 |
    | --- | --- |
    | `new` | 일반 C++ 객체 → 언리얼의 GC와 무관함 (직접 `delete` 필요) |
    | `NewObject<T>()` | `UObject` 생성 → GC 관리 대상 |
    | `UPROPERTY()` | 객체 참조를 **GC 추적 대상으로 등록**함 |
    
    ---
    
    ### 🔧 실수 주의
    
    ```cpp
    // ❌ 이렇게 만들면 GC 추적 안 됨
    MyObject = new UMyObject(); // 일반 C++ 방식
    
    // ✅ 이렇게 해야 GC 관리
    MyObject = NewObject<UMyObject>(this);
    ```
    
    ---
    
    ## ✍️ 핵심 요약 한 줄
    
    > 마크 & 스윕은 살아있는 객체를 추적(mark) 후 죽은 객체를 해제(sweep) 하는 방식이고,
    > 
    > 
    > `UObject`는 언리얼의 **GC, 리플렉션, 직렬화 등 핵심 시스템과 연결된 모든 클래스의 기반**이다.
    > 
    
    ### 🔹 언리얼의 GC 시스템이란?
    
    언리얼 엔진의 GC(Garbage Collection) 시스템은
    
    `UObject` 기반 객체를 자동으로 추적하여 **사용되지 않는 메모리를 해제**해주는 시스템입니다.
    
    즉,
    
    - 메모리 누수를 방지하고
    - 수동 `delete` 없이 객체 수명 관리를 가능하게 합니다.
    
    ---
    
    ### 🔹 GC 작동 방식 요약
    
    1. **루트 객체(예: World, Level 등)** 부터 시작하여
    2. **UPROPERTY로 마킹된 포인터들만 추적**
    3. 참조가 없는 객체는 **마크 & 스윕 방식으로 제거**
    
    > 👉 이 과정은 GC Tick마다 주기적으로 실행되며, GEngine->PerformGarbageCollection() 내부에서 발생함
    > 
    
    ---
    
    ### 🔹 GC 대상 조건
    
    | 조건 | 설명 |
    | --- | --- |
    | `UCLASS()` 매크로로 선언된 클래스 | `UObject` 기반 클래스만 대상 |
    | `NewObject<T>()`, `DuplicateObject()`로 생성 | GC 추적이 가능한 생성 방식 사용 |
    | `UPROPERTY()` 매크로로 마킹된 포인터 | **GC가 참조를 추적할 수 있음** (Raw pointer는 추적 불가) |
    
    ✅ 따라서 `UObject` 포인터라도 `UPROPERTY()`가 없다면 GC는 추적하지 못하므로 **해제되지 않음 → 메모리 누수 발생 가능**
    
    ---
    
    ### 🔹 GC가 동작하지 않는 예 (주의)
    
    ```cpp
    // ❌ GC 추적 대상 아님
    MyObject = NewObject<UMyObject>(); // UPROPERTY 마킹 안 됨
    ```
    
    ```cpp
    // ✅ GC 추적 대상
    UPROPERTY()
    UMyObject* MyObject;
    ```
    
    ---
    
    ## 🧠 면접관 피드백 포인트
    
    | 항목 | 체크 포인트 |
    | --- | --- |
    | GC 시스템 목적 설명 | ✅ 메모리 관리 자동화 |
    | UPROPERTY의 역할 이해 | ✅ 참조 추적을 위한 핵심 요소 |
    | UCLASS / UObject 조건 설명 | ✅ GC 대상의 조건 이해 |
    | 실수 사례 언급 | 🌟 UPROPERTY 빠짐 → 누수 가능 언급 시 가산점 |

---

### 2️⃣ **[C++]**

**Q. C++에서 함수 오버로딩과 함수 템플릿은 어떻게 다르며, 컴파일러는 어떻게 호출 대상을 결정하나요?**

> 🔍 의도: 정적 다형성, 템플릿 분기, 타입 추론에 대한 이해 확인
> 

<aside>
💡

함수 오버로딩은 인자 타입별로 별도 정의하는 방식이고,

함수 템플릿은 타입에 따라 자동으로 생성되는 일반화 함수이며,

오버로딩된 구체 함수가 템플릿보다 우선 선택된다.

</aside>

- **개념**
    
    ## 🔹 구체 함수(concrete function)란?
    
    > 템플릿이 아닌 일반 함수로,
    > 
    > 
    > **타입이 정해진(정적 타입)** 함수 = 컴파일러가 별도로 인스턴스화할 필요 없음
    > 
    
    ### 🔹 함수 오버로딩(Function Overloading)
    
    > 같은 이름의 함수를 다른 파라미터 시그니처로 여러 개 정의하는 문법
    > 
    
    ```cpp
    void Print(int a);
    void Print(double b);
    void Print(std::string s);
    ```
    
    - 컴파일러가 **함수 호출 시점에서 인자의 타입을 기준으로** 가장 적절한 버전을 선택함
    - 모든 오버로드 함수는 **명시적으로 정의되어 있어야 함**
    
    ---
    
    ### 🔹 함수 템플릿(Function Template)
    
    > 하나의 함수 정의로 여러 타입에 대해 자동 생성되도록 하는 일반화 문법
    > 
    
    ```cpp
    template<typename T>
    void Print(T value) {
        std::cout << value << '\n';
    }
    ```
    
    - 컴파일러가 **템플릿 인자 추론**을 통해 호출 시점에 적절한 함수를 **자동 생성** (템플릿 인스턴스화)
    - 타입이 복잡하거나 중복이 많을 때 재사용성이 좋음
    
    ---
    
    ### 📌 주요 차이점 정리
    
    | 항목 | 함수 오버로딩 | 함수 템플릿 |
    | --- | --- | --- |
    | 정의 방식 | 여러 버전 개별 작성 | 하나의 일반화 정의 |
    | 컴파일 시점 | 인자 타입 기준으로 선택 | 인자 타입으로 **인스턴스화** |
    | 목적 | 명확한 타입별 동작 | 타입 독립적 일반 처리 |
    | 유연성 | 고정된 타입 처리 | 제네릭 처리 가능 |
    | 단점 | 타입 많으면 중복 발생 | 디버깅 어려움, 에러 메시지 복잡함 |
    
    ---
    
    ### 💡 혼합 상황 (오버로딩 vs 템플릿 우선순위)
    
    ```cpp
    void Print(int x) {
        std::cout << "int: " << x << '\n';
    }
    
    template<typename T>
    void Print(T x) {
        std::cout << "template: " << x << '\n';
    }
    
    int main() {
        Print(42);     // 👈 int 버전 (오버로드 우선)
        Print(3.14);   // 👈 템플릿 버전
    }
    ```
    
    🔎 **오버로드된 구체 함수가 우선** → 템플릿보다 명확한 타입 매칭이 우선됨
    
    ---
    
    ## 🧠 면접관 피드백 포인트
    
    | 항목 | 평가 기준 |
    | --- | --- |
    | 오버로딩과 템플릿 차이 구분 | ✅ 정의 방식, 사용 목적 명확히 설명 |
    | 컴파일러 결정 과정 이해 | ✅ 타입 추론, 인스턴스화 언급 |
    | 예시 코드 활용 | ✅ 호출 우선순위 예시 설명 |
    | 추가 지식 | 🌟 템플릿 특수화, SFINAE 언급 시 가산점 |

---

### 3️⃣ **[운영체제]**

**Q. 세마포어(Semaphore)와 뮤텍스(Mutex)의 차이점은 무엇이며, 각각 어떤 상황에서 사용하는 것이 적절한가요?**

> 🔍 의도: 동기화 원리, 경쟁 조건 방지 방식 이해
> 

<aside>
💡

Mutex는 한 번에 하나의 스레드만 공유 자원에 접근하도록 제한하는 동기화 도구이고,

Semaphore는 일정 개수의 스레드가 동시에 접근할 수 있게 제어하는 카운팅 기반 동기화 도구이다.

</aside>

- **개념**
    
    **프로세스 = 프로그램 / 스레드 = 프로그램(프로세스) 안에서 실행되는 작업 단위**
    
    ## 🔒 임계 영역(Critical Section)이란?
    
    > 둘 이상의 스레드(또는 프로세스)가 동시에 접근하면 안 되는
    > 
    > 
    > **공유 자원**(예: 전역 변수, 파일, 메모리 등)에 접근하는 코드 영역
    > 
    
    ### 🔹 공통점
    
    - 둘 다 **임계 영역(Critical Section)** 보호를 위한 **동기화 도구**
    - 다중 스레드/프로세스 환경에서 **공유 자원의 충돌 방지** 용도로 사용됨
    
    ---
    
    ## 🔸 차이점 비교
    
    | 항목 | **Mutex** | **Semaphore** |
    | --- | --- | --- |
    | 목적 | **상호 배제(Mutual Exclusion)** | **리소스 접근 제어(Counting)** |
    | 값 | 이진 상태 (Locked / Unlocked) | 정수값 (n ≥ 0) |
    | 소유권 | 소유 개념 있음 (Lock한 스레드만 Unlock 가능) | 소유권 없음 (다른 스레드도 해제 가능) |
    | 사용 예 | 1개만 접근해야 하는 공유 자원 | 동시에 제한된 수만 접근 가능한 자원 (예: 연결 제한) |
    | 유형 | Binary Lock | Counting / Binary 모두 가능 |
    
    ---
    
    ## 🔹 Mutex 예시
    
    ```cpp
    std::mutex mtx;
    mtx.lock();
    // 공유 자원 접근
    mtx.unlock();
    ```
    
    - 한 스레드만 lock 가능 → 다른 스레드는 대기
    - lock한 스레드만 unlock 가능 (엄격한 소유권)
    
    ---
    
    ## 🔹 Semaphore 예시
    
    ```cpp
    std::counting_semaphore<3> sem(3); // 동시에 3개까지 접근 허용
    
    sem.acquire(); // 진입
    // 공유 자원 접근
    sem.release(); // 퇴장
    ```
    
    - 최대 N개 스레드가 동시에 접근 가능
    - `semaphore`은 **프로듀서-컨슈머**, **스레드 풀**, **연결 제한** 같은 패턴에 적합
    
    ---
    
    ## 🧠 면접관 피드백 포인트
    
    | 항목 | 평가 기준 |
    | --- | --- |
    | 동기화 목적 구분 | ✅ 배타적 접근 vs 개수 제한 |
    | 소유권 설명 | ✅ Mutex는 소유권 있음, Semaphore는 없음 |
    | 적절한 사용 예시 제시 | ✅ 공유 자원 보호 vs 제한된 리소스 접근 |
    | 추가 요소 | 🌟 Binary Semaphore = Mutex 유사 / 데드락 주의까지 언급 시 가산점 |

---

### 4️⃣ **[그래픽스]**

**Q. 정점(Vertex) 셰이더(Vertex Shader)와 픽셀(Fragment) 셰이더는 어떤 역할을 하나요?**

> 🔍 의도: GPU 렌더링 파이프라인 각 셰이더 스테이지 이해도 확인
> 

<aside>
💡

정점 셰이더는 정점의 위치와 속성을 변환하고, 픽셀 셰이더는 각 픽셀의 최종 색상을 계산하여 화면에 출력되는 렌더링 결과를 만들어낸다.

</aside>

- **개념**
    
    ### 🔷 GPU 셰이더란?
    
    > 그래픽 파이프라인에서 GPU가 수행하는 작은 프로그램으로,
    > 
    > 
    > 3D 데이터를 화면에 렌더링하기 위한 단계별 계산을 담당합니다.
    > 
    
    ---
    
    ## 🔸 정점 셰이더 (Vertex Shader)
    
    > 3D 모델의 정점(Vertex) 정보를 처리하는 셰이더
    > 
    
    ### ✅ 주요 역할:
    
    - **모델 좌표 → 월드/뷰/스크린 좌표**로 변환
    - 정점 위치(Position), 노멀, UV 등을 처리
    - 보간용 데이터(색, 텍스처 좌표 등)를 다음 단계로 전달
    
    ```
    float4 main(float3 pos : POSITION) : SV_POSITION {
        return mul(ProjectionMatrix, mul(ViewMatrix, mul(WorldMatrix, float4(pos, 1.0))));
    }
    ```
    
    📌 1개의 정점 당 1번 실행됨 → 정점 수가 많아도 비교적 가볍고 병렬 처리됨
    
    ---
    
    ## 🔸 픽셀 셰이더 (Pixel Shader, Fragment Shader)
    
    > 화면의 각 픽셀에 대한 색상 계산을 담당
    > 
    
    ### ✅ 주요 역할:
    
    - 텍스처 샘플링, 조명 계산, 그림자, 반사 처리 등
    - 최종적으로 **화면에 출력될 색상(RGBA)** 결정
    
    ```
    float4 main(float2 uv : TEXCOORD) : SV_Target {
        return tex2D(TextureSampler, uv); // 텍스처 색상 반환
    }
    ```
    
    📌 **해상도(픽셀 수)** 만큼 실행됨 → 처리량 많고 **성능 병목 지점이 될 수 있음**
    
    ---
    
    ## 🔁 파이프라인 흐름 요약
    
    ```
    [정점 데이터] → [정점 셰이더] → [래스터화(Rasterization)] → [픽셀 셰이더] → [프레임버퍼]
    ```
    
    ---
    
    ## 🧠 면접관 피드백 포인트
    
    | 항목 | 평가 기준 |
    | --- | --- |
    | 셰이더 목적 구분 | ✅ Vertex = 위치 계산 / Pixel = 색상 계산 |
    | 실행 단위 설명 | ✅ 정점 단위 vs 픽셀 단위 |
    | 예시 코드/활용 설명 | ✅ 텍스처 샘플링, 변환 행렬 등 |
    | 고급 요소 | 🌟 Geometry/Compute Shader 등 언급 시 가산점 |

---

### 5️⃣ **[알고리즘]**

**Q. 이진 탐색(Binary Search)이란 무엇이며, 시간 복잡도는 어떻게 계산되나요? 정렬되지 않은 배열에 사용할 수 없는 이유도 설명해주세요.**

> 🔍 의도: 탐색 알고리즘의 원리, 전제 조건, 시간 복잡도 분석 능력 확인
> 

<aside>
💡

이진 탐색은 정렬된 배열에서 중간 값을 기준으로 범위를 반씩 줄여가며 탐색하는 알고리즘으로, 시간 복잡도는 O(log N)이며, 정렬이 되어 있지 않다면 정확히 동작할 수 없다.

</aside>

- **개념**
    
    ### 🔹 이진 탐색이란?
    
    > 정렬된 배열에서 원하는 값을 빠르게 찾기 위한 알고리즘입니다.
    > 
    > 
    > 검색 범위를 절반씩 줄여가며 중간 값을 기준으로 탐색합니다.
    > 
    
    ---
    
    ### 🔹 기본 원리
    
    1. 배열의 **중간값(mid)** 을 기준으로
    2. 찾고자 하는 값(target)이
        - mid보다 작으면 왼쪽 절반으로
        - mid보다 크면 오른쪽 절반으로 **검색 범위 축소**
    3. 반복 또는 재귀로 수행하며, 값을 찾거나 검색 범위가 없어질 때까지 진행
    
    ---
    
    ### 🔹 예시 코드 (C++)
    
    ```cpp
    int binarySearch(const std::vector<int>& arr, int target) {
        int left = 0, right = arr.size() - 1;
    
        while (left <= right) {
            int mid = (left + right) / 2;
    
            if (arr[mid] == target) return mid;
            else if (arr[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return -1; // Not found
    }
    ```
    
    ---
    
    ### 🔹 시간 복잡도
    
    | 단계 수 | 설명 |
    | --- | --- |
    | 매 단계마다 범위를 절반으로 줄임 | ⇒ $N \rightarrow N/2 \rightarrow N/4 \rightarrow ...$ |
    | 탐색 횟수 | 최대 $\log_2(N)$ 회 |
    | **결론** | **O(log N)** |
    
    ---
    
    ### 🔹 왜 정렬이 되어 있어야 하나요?
    
    > 이진 탐색은 중간 값을 기준으로 왼쪽/오른쪽이 "정확히 정렬되어 있을 것"을 전제로 동작합니다.
    > 
    - 정렬되어 있지 않다면 `arr[mid] < target`이라는 판단 자체가 **의미가 없음**
    - 잘못된 방향으로 탐색하게 되어 **정확성을 보장할 수 없음**
    
    ---
    
    ### 💡 예: 정렬 안 된 배열
    
    ```cpp
    int arr[] = {5, 2, 8, 1, 7}; // 정렬되지 않음
    
    // Binary Search 사용 → 잘못된 결과 도출 가능
    ```
    
    > 이런 경우에는 선형 탐색(Linear Search, O(N))을 사용해야 합니다.
    > 
    
    ---
    
    ## 🧠 면접관 피드백 포인트
    
    | 항목 | 평가 기준 |
    | --- | --- |
    | 탐색 방식 설명 | ✅ 중간 값, 범위 절반 줄이기 개념 정확히 이해 |
    | 시간 복잡도 계산 | ✅ 로그 기반으로 설명 |
    | 정렬 조건 이유 | ✅ 정렬이 전제 조건임을 명확히 설명 |
    | 예외 상황 설명 | 🌟 정렬 안 된 배열에 사용할 수 없는 이유 예시 포함 시 가산점 |*/

// 고양이
#include <iostream>
using namespace std;

int main()
{
    cout << "\\    /\\" << endl;
    cout << " )  ( ')" << endl;
    cout << "(  /  )" << endl;
    cout << " \\(__)|" << endl;
    return 0;
}

/* C++
 * 문자열 클래스 만들기
