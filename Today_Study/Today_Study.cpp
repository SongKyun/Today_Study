/*# 6/24 : Replication / RPC / unique_ptr / shared_ptr / Context Switching / 텍스처 매핑

### 5️⃣ **언리얼 엔진**

**Q. 언리얼에서 Replication(복제)과 RPC(Remote Procedure Call)의 차이는 무엇이며, 각각은 어떤 상황에서 사용하나요?**

> 🔍 의도: 네트워크 동기화와 통신 구조에 대한 이해도 확인
> 
> 
> → **변수 복제 vs 함수 호출**의 개념적 차이를 알고 있는지
> 

<aside>
💡

Replication은 서버에서 클라이언트로 변수 값을 자동 복제하는 기능이고, RPC는 네트워크를 통해 명시적으로 함수를 호출하는 메커니즘이다. 각각 상태 동기화 vs 행동 전달에 적합하다.

</aside>

- **개념**
    
    ### 🔹 Replication (변수 복제)
    
    - **목적**: 서버에서 특정 변수 값을 **자동으로 클라이언트에 동기화**
    - **대상**: `UPROPERTY(Replicated)`로 지정된 멤버 변수
    - **작동 원리**:
        - 서버가 값을 바꾸면, 해당 변수는 **지정된 클라이언트들에게 자동 복사**됨
        - 조건 설정 가능 (`COND_OwnerOnly`, `COND_SkipOwner` 등)
    - **예시 상황**:
        - 체력, 위치, 탄약 수 등 클라이언트가 **알아야 할 상태 값** 공유
    
    ```cpp
    UPROPERTY(ReplicatedUsing=OnRep_Health)
    float Health;
    
    UFUNCTION()
    void OnRep_Health();
    ```
    
    ---
    
    ### 🔹 RPC (함수 원격 호출)
    
    - **목적**: **한 쪽에서 다른 쪽으로 함수 호출** (주로 클라이언트 → 서버 or 서버 → 클라이언트)
    - **종류**:
        - `Server` RPC: 클라이언트 → 서버 호출
        - `Client` RPC: 서버 → 클라이언트 호출
        - `Multicast` RPC: 서버 → 모든 클라이언트 호출
    - **예시 상황**:
        - 서버에게 총을 쐈다고 알리기 → `ServerFire()`
        - 서버가 모든 클라에게 이펙트 보여주기 → `MulticastPlayExplosion()`
    
    ```cpp
    UFUNCTION(Server, Reliable)
    void ServerFire();
    
    UFUNCTION(NetMulticast, Unreliable)
    void MulticastPlayExplosion();
    ```
    
    ---
    
    ## 🔍 차이 요약 표
    
    | 항목 | Replication | RPC |
    | --- | --- | --- |
    | 대상 | 변수 | 함수 |
    | 방향 | 서버 → 클라 | 양방향 가능 (클라→서버, 서버→클라) |
    | 자동/수동 | 자동 동기화 | 명시적 호출 |
    | 예시 | 체력, 탄약 상태 | 총 발사, 이펙트 재생 |
    
    ---
    
    ## 🧠 면접관 피드백 포인트
    
    | 항목 | 평가 기준 |
    | --- | --- |
    | Replication의 자동성 이해 | ✅ `UPROPERTY`로 관리되는 변수의 자동 동기화 |
    | RPC의 목적 설명 | ✅ 호출 흐름(클라→서버, 서버→클라)을 구분했는가 |
    | 예시 적절성 | ✅ 상태 vs 행동을 잘 구분했는가 |
    | Reliable/Unreliable 차이까지 언급 | 🌟 가산점 요소 |

### 6️⃣ **C++**

**Q. 스마트 포인터 중 `unique_ptr`과 `shared_ptr`의 차이는 무엇인가요? 각각의 사용 시점과 주의할 점도 함께 설명해보세요.**

> 🔍 의도: 자원 관리 방식, 참조 카운팅 개념, 복사/이동 시점 이해 평가
> 

<aside>
💡

unique_ptr은 단독 소유와 빠른 해제를 보장하고, shared_ptr은 여러 곳에서 공유 가능한 객체에 쓰이며, 사용 시 참조 카운트와 순환 참조에 주의해야 한다.

</aside>

- **개념**
    
    ### 🔹 `unique_ptr`
    
    - **단독 소유권**을 가지는 스마트 포인터
    - 하나의 객체를 **오직 한 곳에서만 소유** 가능
    - 복사는 불가능하고, **이동(ownership transfer)** 만 가능
    - **가볍고 빠름** → 오버헤드 거의 없음
    
    ```cpp
    std::unique_ptr<MyClass> a = std::make_unique<MyClass>();
    // std::unique_ptr<MyClass> b = a; // ❌ 복사 불가
    std::unique_ptr<MyClass> b = std::move(a); // ✅ 이동 가능
    ```
    
    ### ✅ 사용 시점
    
    - 객체를 **하나의 주체만** 소유할 때
    - 리소스를 명확하게 관리하고 싶은 경우 (ex. 함수 내부 임시 자원, RAII)
    
    ---
    
    ### 🔹 `shared_ptr`
    
    - 여러 곳에서 같은 객체를 **공유** 가능
    - 내부적으로 **참조 카운트(reference count)** 사용
    - 마지막 하나가 소멸할 때 객체가 해제됨
    - 비교적 **오버헤드 있음**
    
    ```cpp
    std::shared_ptr<MyClass> a = std::make_shared<MyClass>();
    std::shared_ptr<MyClass> b = a; // ✅ 공유 가능
    ```
    
    ### ✅ 사용 시점
    
    - 복수의 객체가 같은 리소스를 참조해야 할 때 (ex. 이벤트 시스템, 리소스 캐시)
    - 객체 수명이 명확히 한 곳에서 결정되지 않는 경우
    
    ---
    
    ## 🔸 주의할 점
    
    | 스마트 포인터 | 주의사항 |
    | --- | --- |
    | `unique_ptr` | 이동 후 원 포인터는 nullptr → 사용 시 주의 |
    | `shared_ptr` | 순환 참조(Circular Reference) 주의 → `weak_ptr`로 끊어야 함 |
    | 공통 | 스마트 포인터끼리 **raw pointer처럼 비교하거나 delete 호출 금지** |
    
    ---
    
    ## 🧠 면접관 피드백 포인트
    
    | 항목 | 평가 기준 |
    | --- | --- |
    | 개념 구분 명확 | ✅ 소유권, 참조 카운트, 복사/이동 가능 여부 |
    | 코드 예시 적절 | ✅ `make_unique` / `make_shared` 사용 |
    | 사용 시점 판단 | ✅ 단독 소유 vs 공유 참조 |
    | 위험 요소 언급 | 🌟 순환 참조, dangling 포인터 언급 시 가산점 |
    
    ### 🔁 순환 참조 (Circular Reference)
    
    > shared_ptr끼리 서로를 참조하면서 참조 카운트가 0이 되지 않아 메모리 누수가 발생하는 상황
    > 
    
    ### ☠️ 댕글링 포인터 (Dangling Pointer)
    
    > 이미 해제된 메모리를 참조하고 있는 잘못된 포인터
    > 

### 7️⃣ **운영체제**

**Q. Context Switching이란 무엇이며, 게임과 같은 실시간 시스템에서 과도한 Context Switch가 발생하면 어떤 문제가 생길 수 있나요?**

> 🔍 의도: 스케줄링 비용, 실시간 성능 저하 요소 이해
> 

<aside>
💡

컨텍스트 스위칭은 CPU가 다른 작업으로 전환될 때 발생하는 상태 저장/복원 과정이며, 실시간성이 중요한 게임 클라이언트에서는 지나치면 프레임 저하와 지연 현상을 초래할 수 있다.

</aside>

- **개념**
    
    ### 🔹 Context Switching이란?
    
    > 운영체제가 CPU를 여러 프로세스/스레드에 분배할 때,
    > 
    > 
    > 현재 실행 중인 작업의 **문맥(Context)** 을 저장하고, 다음 작업의 상태를 불러오는 과정입니다.
    > 
    
    즉,
    
    - 이전 작업의 레지스터, 프로그램 카운터, 스택 포인터 등을 저장하고
    - 새 작업의 상태로 교체 → CPU가 다른 작업을 **이어받아 실행 가능하게** 합니다.
    
    ---
    
    ### 🔹 게임에서 과도한 Context Switching의 문제
    
    게임 클라이언트는 **실시간 반응성, 프레임 유지**가 매우 중요한 시스템입니다.
    
    과도한 Context Switch는 다음과 같은 부작용을 유발합니다:
    
    1. **CPU 캐시 무효화**
        
        → 스레드 변경 시 레지스터, 캐시 초기화 → **성능 저하**
        
    2. **스케줄링 지연 (Latency)**
        
        → 중요한 쓰레드(예: Game Thread)가 **예기치 않게 밀릴 수 있음**
        
    3. **과도한 커널 모드 전환 비용**
        
        → OS 스케줄러 호출이 잦아짐 → 오버헤드 증가
        
    4. **멀티스레딩 구조의 비효율**
        
        → 작업이 자주 중단/재개되면, 동기화 비용(Race condition, Mutex 등)이 커짐
        
    
    ---
    
    ### 📌 예시
    
    - 물리 연산, 렌더링, 애니메이션, 네트워크가 **모두 별도 쓰레드**에서 돌고 있는데
    - 과도한 우선순위 변경 또는 락 경합 때문에 쓰레드 전환이 잦아지면
        
        → **프레임 드랍, 입력 지연, 로딩 지연** 발생
        
    
    ---
    
    ## 🧠 면접관 피드백 포인트
    
    | 항목 | 평가 기준 |
    | --- | --- |
    | Context Switching 정의 | ✅ CPU 상태 저장/복원 개념 이해 |
    | 게임과의 연관성 설명 | ✅ 실시간성, 성능 저하 연결 |
    | 예시 언급 | ✅ 캐시 손실, 스케줄링 지연 등 언급 |
    | 가산점 요소 | 🌟 쓰레드 스케줄러/락 경합까지 연결 시 + |

### 8️⃣ **그래픽스**

**Q. 텍스처 매핑(Texture Mapping)이란 무엇이며, 텍스처 필터링(예: Bilinear, Trilinear, Mipmap)은 왜 필요한가요?**

> 🔍 의도: 실시간 렌더링에서 텍스처 품질과 퍼포먼스의 균형에 대한 이해
> 

<aside>
💡

텍스처 매핑은 3D 표면에 이미지를 입히는 기술이고, 필터링은 이를 부드럽고 선명하게 보이게 하기 위해 필요한 샘플링 보간 기법이다. 대표적으로 Bilinear, Trilinear, Mipmap 등이 있다.

</aside>

- **개념**
    
    ### 🔹 UV 좌표란?
    
    - **U, V는 텍스처 이미지의 가로(U), 세로(V) 방향을 의미**하는 축입니다.
    - 일반적인 좌표계인 XYZ(3D 공간상의 위치)와는 다르게, **UV는 2D 이미지(텍스처)상에서의 위치를 나타냅니다.**
    - 텍스처 이미지 상에서 `(0, 0)`은 **좌하단**, `(1, 1)`은 **우상단**입니다.
    
    ### 🔸 왜 UV라고 하나요?
    
    - X, Y는 이미 3D 공간 좌표에서 사용되고 있어서, 혼동을 피하기 위해 **텍스처 좌표에는 U, V라는 명칭**을 사용합니다.
    
    ### 샘플링 (Sampling)
    
    - **샘플링은 텍스처나 신호 등에서 특정 위치의 값을 뽑아내는 것**입니다.
    - 예를 들어, 텍스처 좌표(UV)로부터 해당 위치의 픽셀 색상을 읽어오는 과정이에요.
    
    ### 보간 (Interpolation)
    
    - **보간은 두 개 이상의 샘플 값을 이용해 중간 값을 계산하는 것**입니다.
    - 예를 들어, 텍스처에서 좌표가 픽셀 정중앙이 아닐 때, 인접한 픽셀 색상을 가중 평균해 부드러운 색상을 만드는 기법입니다.
    
    ### 🔹 텍스처 매핑(Texture Mapping)이란?
    
    > 3D 모델의 표면에 2D 이미지를 입혀서, 보다 현실적인 외형을 표현하는 기법입니다.
    > 
    - 3D 좌표의 각 면(Vertex/Fragment)에 **UV 좌표(0~1 범위)** 를 대응시켜
    - 텍스처 이미지의 **색상 데이터를 샘플링**하여 렌더링
    
    ```
    
    3D 모델 (Mesh) ↔ UV 좌표 ↔ 텍스처 이미지
    ```
    
    ---
    
    ### 🔹 텍스처 필터링(Texture Filtering)이란?
    
    > 텍스처 매핑 시, 화면 해상도와 텍스처 해상도가 다를 때 픽셀(텍셀) 을 보간하는 방식입니다.
    > 
    
    ### 📌 왜 필요한가요?
    
    - 거리에 따라 텍스처가 **늘어나거나 줄어들며** 왜곡될 수 있음
    - 이 때, 적절한 보간/샘플링이 없으면 **깨짐, 깜빡임(Aliasing)** 발생
    
    ---
    
    ### 🔹 주요 필터링 종류
    
    | 필터링 종류 | 설명 |
    | --- | --- |
    | **Nearest** | 가장 가까운 텍셀 1개 샘플 → **깨짐 심함, 빠름** |
    | **Bilinear** | 주변 4개 텍셀 선형 보간 → 부드러움 |
    | **Trilinear** | Bilinear + Mipmap 보간 → 거리 변화에 더 부드러움 |
    | **Anisotropic** | 원근 왜곡 보정 → 비스듬한 표면에서 선명함 유지 |
    
    ---
    
    ### 🔹 Mipmap이란?
    
    > 거리에 따라 텍스처를 미리 축소한 버전들을 계층 구조로 만들어 사용하는 기술
    > 
    > 
    > → **성능 향상 + 깜빡임 감소**
    > 
    
    ---
    
    ### 🧠 면접관 피드백 포인트
    
    | 항목 | 평가 기준 |
    | --- | --- |
    | 텍스처 매핑 정의 | ✅ UV 좌표 개념 이해 |
    | 필터링 목적 설명 | ✅ 왜곡, aliasing 감소 설명 |
    | 필터링 종류 구분 | ✅ Bilinear, Trilinear 차이 명확히 설명 |
    | 고급 요소 | 🌟 Anisotropic, Mipmap까지 언급 시 + |
    */

/*#include <iostream>

int main()
{
    std::cout << "Hello World!";
    return 0;
}*/

//생성자 초기화 리스트/const/static/레퍼런스 타입 리턴 함수/this 포인터/const 멤버 함수